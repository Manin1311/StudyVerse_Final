
from flask import Blueprint, render_template, request, flash, redirect, url_for, jsonify
from flask_login import login_required, current_user
from extensions import db
from models import SyllabusDocument, Todo, TopicProficiency
from services.syllabus import SyllabusService
from datetime import datetime, timedelta
import io

syllabus_bp = Blueprint('syllabus', __name__)

@syllabus_bp.route('/syllabus')
@syllabus_bp.route('/syllabus/<int:view_id>')
@login_required
def index(view_id=None):
    # Get all docs sorted by newest first
    all_docs = SyllabusDocument.query.filter_by(user_id=current_user.id).order_by(SyllabusDocument.created_at.desc()).all()
    
    if not all_docs:
        doc = None
        archived_docs = []
    else:
        # If view_id is provided, find that doc
        if view_id:
            doc = next((d for d in all_docs if d.id == view_id), None)
            # If not found (unauthorized?), fallback to newest
            if not doc:
                doc = all_docs[0]
        else:
            # Default to newest (Active)
            doc = all_docs[0]
            
        archived_docs = [d for d in all_docs if d.id != doc.id]

    current_view_id = doc.id if doc else None
    
    chapters = SyllabusService.build_chapters_from_todos(current_user.id, syllabus_id=current_view_id)
    total_topics = sum(c['total'] for c in chapters)
    completed_topics = sum(c['completed'] for c in chapters)
    avg_completion = int((completed_topics / total_topics) * 100) if total_topics else 0
    
    return render_template(
        'syllabus.html',
        syllabus_doc=doc,
        archived_docs=archived_docs,
        chapters=chapters,
        chapters_count=len(chapters),
        topics_count=total_topics,
        completed_count=completed_topics,
        avg_completion=avg_completion,
    )

@syllabus_bp.route('/syllabus/restore/<int:doc_id>', methods=['POST'])
@login_required
def restore(doc_id):
    """Restore an archived syllabus by making it the most recent."""
    doc = SyllabusDocument.query.get_or_404(doc_id)
    if doc.user_id != current_user.id:
        flash('Unauthorized.', 'error')
        return redirect(url_for('syllabus.index'))
    
    # Update its created_at to now to make it 'current'
    doc.created_at = datetime.utcnow()
    db.session.commit()
    
    flash(f'Restored {doc.filename} as active syllabus.', 'success')
    return redirect(url_for('syllabus.index'))

@syllabus_bp.route('/syllabus/upload', methods=['POST'])
@login_required
def upload():
    """Upload and extract PDF syllabus."""
    uploaded = request.files.get('pdf')
    if not uploaded:
        flash('Please select a PDF file.', 'error')
        return redirect(url_for('syllabus.index'))

    filename = uploaded.filename or 'syllabus.pdf'

    pdf_bytes = uploaded.read()
    if not pdf_bytes:
        flash('Uploaded PDF was empty.', 'error')
        return redirect(url_for('syllabus.index'))

    # AI: Extract tasks directly from the PDF using Gemini (real API).
    tasks = []
    try:
        tasks = SyllabusService.extract_tasks_from_pdf(pdf_bytes)
    except Exception as e:
        flash(f'AI task extraction failed: {str(e)}', 'error')

    # Extract text with PyPDF2 (used as context for chat). Some PDFs (scans) may yield no text.
    extracted = ""
    try:
        from PyPDF2 import PdfReader
        reader = PdfReader(io.BytesIO(pdf_bytes))
        parts = []
        for page in reader.pages:
            text = page.extract_text() or ''
            parts.append(text)
        extracted = "\n".join(parts).strip()
    except Exception:
        extracted = ""

    if not extracted:
        # Keep a non-empty placeholder because SyllabusDocument.extracted_text is NOT NULL.
        extracted = f"(No text could be extracted from this PDF. It may be a scanned document.)\nFilename: {filename}"
        flash('PDF uploaded, but no text could be extracted (might be scanned image). Tasks can still be generated by AI.', 'error')

    doc = SyllabusService.save_syllabus(current_user.id, filename, extracted)

    # Persist AI-generated tasks into real Todos.
    target_date_str = request.form.get('target_date')
    target_date = None
    days_diff = 1
    
    if target_date_str:
        try:
            target_date = datetime.strptime(target_date_str, '%Y-%m-%d')
            today = datetime.now()
            days_diff = (target_date - today).days
            if days_diff <= 0:
                 days_diff = 1 # Minimum 1 day
        except ValueError:
            pass

    # Count total items to be created for distribution
    total_items = 0
    if tasks:
        for task in tasks:
            total_items += 1 # Chapter task
            total_items += len(task.get("subtasks", []))
            
    items_per_day = 1
    if total_items > 0 and days_diff > 0:
        import math
        items_per_day = math.ceil(total_items / days_diff)

    completed_items_count = 0
    created_count = 0
    
    if tasks:
        for task in tasks:
            chapter = str(task.get("title", "")).strip() or "Chapter"
            subtasks = task.get("subtasks", [])
            chapter_category = chapter[:50]

            # Calculate Due Date
            day_offset = completed_items_count // items_per_day
            due_date_obj = datetime.now() + timedelta(days=day_offset)
            due_date_str = due_date_obj.strftime('%Y-%m-%d') if target_date else None

            # Create a parent todo for the chapter
            chapter_title = chapter[:200]
            exists = Todo.query.filter_by(user_id=current_user.id, title=chapter_title, category=chapter_category, is_group=False).first()
            if not exists:
                db.session.add(Todo(
                    user_id=current_user.id,
                    title=chapter_title,
                    completed=False,
                    priority='high', # Chapters are main goals
                    due_date=due_date_str,
                    category=chapter_category,
                    is_group=False,
                    syllabus_id=doc.id  # Link to this syllabus
                ))
                created_count += 1
            
            completed_items_count += 1

            if isinstance(subtasks, list):
                for sub in subtasks:
                    sub_title = str(sub).strip()
                    if not sub_title:
                        continue
                    sub_title = sub_title[:200]
                    
                    # Recalculate due date for subtasks as well to distribute them
                    day_offset = completed_items_count // items_per_day
                    due_date_obj = datetime.now() + timedelta(days=day_offset)
                    due_date_str = due_date_obj.strftime('%Y-%m-%d') if target_date else None
                    
                    exists = Todo.query.filter_by(user_id=current_user.id, title=sub_title, category=chapter_category, is_group=False).first()
                    if exists:
                        continue
                    db.session.add(Todo(
                        user_id=current_user.id,
                        title=sub_title,
                        completed=False,
                        priority='medium',
                        due_date=due_date_str,
                        category=chapter_category,
                        is_group=False,
                        syllabus_id=doc.id  # Link to this syllabus
                    ))
                    created_count += 1
                    completed_items_count += 1

        db.session.commit()

    if created_count > 0:
        flash(f'Created {created_count} tasks from PDF using Gemini!', 'success')
    else:
        flash('PDF uploaded and processed successfully!', 'success')
    return redirect(url_for('syllabus.index'))

@syllabus_bp.route('/api/update_proficiency', methods=['POST'])
@login_required
def update_proficiency():
    data = request.get_json()
    if not data:
        return jsonify({'error': 'No data'}), 400
        
    topic_name = data.get('topic_name')
    score = data.get('score')
    
    if not topic_name or score is None:
        return jsonify({'error': 'Missing fields'}), 400
        
    try:
        score = int(score)
        if score <= 10:
             score = score * 10
    except:
        return jsonify({'error': 'Invalid score'}), 400

    topic = TopicProficiency.query.filter_by(user_id=current_user.id, topic_name=topic_name).first()
    if not topic:
        topic = TopicProficiency(user_id=current_user.id, topic_name=topic_name, proficiency=score)
        db.session.add(topic)
    else:
        topic.proficiency = score
        topic.updated_at = datetime.utcnow()
        
    db.session.commit()
    return jsonify({'status': 'success', 'new_score': topic.proficiency})

@syllabus_bp.route('/api/syllabus_graph')
@login_required
def graph():
    """Return JSON data for 3D Force Graph."""
    chapters = SyllabusService.build_chapters_from_todos(current_user.id)
    
    nodes = []
    links = []
    
    # Root Node
    nodes.append({'id': 'My Galaxy', 'group': 0, 'val': 30, 'color': '#ffffff'})
    
    for chapter in chapters:
        cat_name = chapter['name']
        # Chapter Node
        nodes.append({
            'id': cat_name,
            'group': 1,
            'val': 15,
            'color': '#60a5fa' # Blue
        })
        links.append({
            'source': 'My Galaxy',
            'target': cat_name
        })
        
        # Topic Nodes
        for t in chapter['todos']:
            t_title = t.title[:30] + '...' if len(t.title) > 30 else t.title
            
            node_id = f"{cat_name} || {t_title}" 
            
            color = '#4ade80' if t.completed else '#f43f5e' # Green or Red
            
            nodes.append({
                'id': node_id,
                'name': t_title, 
                'group': 2,
                'val': 5,
                'color': color
            })
            links.append({
                'source': cat_name,
                'target': node_id
            })
            
    return jsonify({'nodes': nodes, 'links': links})
